var $get = Symbol.for('FluidValue.get');
var $observers = Symbol.for('FluidValue.observers');
export { FluidValue, hasFluidValue, getFluidValue, getFluidObservers, callFluidObserver, callFluidObservers, 
// Mutations
setFluidGetter, addFluidObserver, removeFluidObserver, };
/** Returns true if `arg` can be observed. */
var hasFluidValue = function (arg) { return Boolean(arg && arg[$get]); };
/**
 * Get the current value.
 * If `arg` is not observable, `arg` is returned.
 */
var getFluidValue = function (arg) {
    return arg && arg[$get] ? arg[$get]() : arg;
};
/** Get the current observer set. Never mutate it directly! */
var getFluidObservers = function (target) {
    return target[$observers] || null;
};
function callFluidObserver(observer, event) {
    if (observer.eventObserved) {
        observer.eventObserved(event);
    }
    else {
        observer(event);
    }
}
function callFluidObservers(target, event) {
    var observers = target[$observers];
    if (observers) {
        observers.forEach(function (observer) {
            callFluidObserver(observer, event);
        });
    }
}
/**
 * Extend this class for automatic TypeScript support when passing this
 * value to `fluids`-compatible libraries.
 */
var FluidValue = /** @class */ (function () {
    function FluidValue(get) {
        if (!get && !(get = this.get)) {
            throw Error('Unknown getter');
        }
        setFluidGetter(this, get);
    }
    return FluidValue;
}());
/** Define the getter called by `getFluidValue`. */
var setFluidGetter = function (target, get) {
    return setHidden(target, $get, get);
};
function addFluidObserver(target, observer) {
    if (target[$get]) {
        var observers = target[$observers];
        if (!observers) {
            setHidden(target, $observers, (observers = new Set()));
        }
        if (!observers.has(observer)) {
            observers.add(observer);
            if (target.observerAdded) {
                target.observerAdded(observers.size, observer);
            }
        }
    }
    return observer;
}
function removeFluidObserver(target, observer) {
    var observers = target[$observers];
    if (observers && observers.has(observer)) {
        var count = observers.size - 1;
        if (count) {
            observers.delete(observer);
        }
        else {
            setHidden(target, $observers, null);
        }
        if (target.observerRemoved) {
            target.observerRemoved(count, observer);
        }
    }
}
var setHidden = function (target, key, value) {
    return Object.defineProperty(target, key, {
        value: value,
        writable: true,
        configurable: true,
    });
};
//# sourceMappingURL=index.js.map